>>课程设计报告，包含选题描述、设计⽅案、代码模块的功能划分与描述、实现效果等。

# 贪吃蛇：
## 一.总述
### 1.选题描述：
  题⽬背景
贪吃蛇是⼀款家喻⼾晓的⼩游戏，⽤⼾通过控制贪吃蛇上下左右移动来收集⻝物块，从⼀条⼩蛇成⻓
为庞然⼤物。贪吃蛇初始时为⼀条⼩蛇，每吃掉⼀块⻝物，它的尾巴就会变⻓⼀截。众所周知它很贪
吃，所以吃掉最多的⻝物是它的⽬标。但它贪吃的过了头，如果贪吃蛇咬到了⾃⼰的尾巴，它就会把
⾃⼰吃掉导致游戏结束；另外，如果贪吃蛇撞上了⽯头或游戏边界的墙壁，游戏也会结束。
搭建环境
编写代码实现游戏的规则和可视化，能够让玩家通过⽅向键控制⼩蛇移动来吞吃⻝物。该阶段不考虑
环境障碍物。
1. 设计⼀个 ⼤⼩的游戏环境，四周由墙壁围起。环境中存在 1 个可以被⻝⽤的⻝物⽅块，
如果⻝物被吃掉，则⽴即在空闲的格⼦中产⽣⼀个⻝物⽅块。
N × M
2. 设计⼀条贪吃蛇，由蛇头和尾巴构成，初始尾巴的⻓度为 2。蛇头可以进⾏前进，左转，右转三种
运动。在⼀个时间步内，⼩蛇可以前进⼀格。当蛇头撞到⻝物时，蛇⻓度 +1。当蛇头撞到墙壁，则
⼩蛇死亡，游戏结束，统计分数。
编写策略
1. 尝试设计搜索算法，让贪吃蛇可以安全的吃到尽可能多的⻝物。参考 A Star 寻路算法 或 BFS 算法
2. 尽可能让贪吃蛇的⻓度增⻓能够填满整个游戏空间

### 2.AI蛇设计方案:
    (1)首先：实现界面画，蛇需要一个界面来跑路
    选择：pygame进行输入图形界面,事实证明pygame的界面还是可以的，非常的好看
    (2)需要让蛇蛇跑起来，需要很多的函数。
      首先问题，不能只靠BFS，蛇会撞死，不确定蛇每个时间段都有走的地方，而且wander函数也会导致蛇死亡...
      https://hawstein.com/2013/04/15/snake-ai/
      这个教案里面的链接给出了一个高瞻远瞩的蛇的版本
      具体说的是:蛇吃完东西之后，还沿着原路运动，追尾这样就是安全的。所以每次吃完了都需要重新BFS，而这样就有：
        1. 目标是食物时，走最短路径
        2. 目标是蛇尾时，走最长路径
        这样蛇就不会死了
        但因为食物随机生成，蛇有可能会跑死，好吧这样的话我就引入一个检查重复路径的函数，这样蛇就要死也死的比较有理有据
        （其实我在网上参考了不下15个贪吃蛇的代码，都大同小异，基本设计方案和函数都是差不多的，只是界面不一样，我觉得优化比起来更重要一点。）

        根据研究和上网查询发现基本需要以下一些函数：
         开关界面（开始界面和结束界面） 
         按键读取（准确的说是开始的时候需要玩家按任意一个按键开始蛇）
         得分（就是蛇的长度）
         randomfood（随机生成米）
         showfood（显示米）
         showsnake（显示蛇蛇）
         pygame-net（网格函数）
         check空位置函数（空位置可以走和生成食物）
         check蛇运动可行性的函数（蛇可不可以向这几个方向走）
         重置面板函数（蛇会动，就得刷新）
          BFS算出蛇的最优路径函数（感谢csdn的BFS算法的研究，参考网站在源代码里面）
          最短路径选择函数
          运动后head定位函数（找到之后的蛇头位置）
          虚拟蛇（判断此路径是否可以走，这是网上那个博客给的思路，还可以，防止蛇死了）
          蛇头追蛇尾存路函数（防止蛇进死路，这样可以保证蛇每一次都有路可以走）
          在蛇头找一个最远路径函数（防止撞上）
          蛇头朝蛇尾运动函数
          安全路径函数（防止撞死）
          wander函数（各种方案无效，没病走两步，不然死了）

    （3）说法是，这些函数实现了，蛇一般能跑了，但是如果蛇重复走一个路径过多次，经过实验，发现在最后还有几个空格的时候会死局，那么这个时候我们需要一个路径记录函数
        路径记录函数：若一个蛇以同一个运动路径运动五次以上，则认定本局为死局，及蛇再也吃不到了，直接转到退出界面

    (4)以上就是蛇的一些想法，感觉还是比较现实的。实际上全是bug

### 3.人工操作蛇设计方案：
    （1）首先，人工的蛇也需要一个界面来跑路，首先实现pygame的界面
    （2）其次，因为先写的ai蛇，所以人工的蛇的代码我就直接从ai蛇复制了，其实差距不大，基本就一个感觉：
    下面说一下我的函数构成以及用户体验优化：
    函数：
          close函数，拿来关界面的
          start函数，用于pygame界面的初始化
          end结算界面，主要是用于退出程序
          check——press函数，从ai蛇copy而来，键盘操作读取函数
          score沿用与ai的得分记录函数
          random随机爆米函数以及show米函数
          snake——show蛇蛇生成函数
          net-generate制表函数
          独有函数turn——over转向函数（这个函数在ai里面是没有的，只有这里需要操作读取）
          check——boom边界控制函数
          game——startal游戏开始函数
          运行就不说了......
    （3）人工蛇主要是优化一手用户体验，所以我设置了让用户自选速度和图表大小，这样更人性化，同时完善了边界条件...
    （4）目前已经实现了人工贪吃蛇，效果很不错，看来是很好的

## 二.代码模块的功能划分与描述
### (1).人工蛇：
#### (1).tkinter进入模块:
```python
import tkinter as tk
from tkinter import messagebox
win = tk.Tk()
win.title("snake_not_ai")
screenWidth = win.winfo_screenwidth()  # 获取显示区域的宽度
screenHeight = win.winfo_screenheight()  # 获取显示区域的高度
width = 300  # 设定窗口宽度
height = 160  # 设定窗口高度
left = (screenWidth - width) / 2
top = (screenHeight - height) / 2
# 在设定宽度和高度的基础上指定窗口相对于屏幕左上角的偏移位置
win.geometry("%dx%d+%d+%d" % (width, height, left, top))
win.resizable(0,0)
# 将俩个标签分别布置在第一行、第二行
tk.Label(win, text="WIDTH(400-1200 & WIDTH%20=0)").grid(row=0)
tk.Label(win, text="HEIGHT(400-1200 & HEIGHT%20=0)").grid(row=1)
tk.Label(win, text="GAME_RATE(1-20)").grid(row=2)
# 创建输入框控件
e1 = tk.Entry(win)
e2 = tk.Entry(win)
e3 = tk.Entry(win)
e1.grid(row=0, column=1, padx=10, pady=5)
e2.grid(row=1, column=1, padx=10, pady=5)
e3.grid(row=2, column=1, padx=10, pady=5)
# 使用 grid()的函数来布局，并控制按钮的显示位置
def get_input():
    global WIDTH,HEIGHT,GAME_RATE
    WIDTH= e1.get()
    HEIGHT=e2.get()
    GAME_RATE=e3.get()
    if (int(WIDTH)>=400 and int(WIDTH)<=1200 and int(WIDTH)%20==0) and (int(HEIGHT)>=400 and int(HEIGHT)<=1200 and int(HEIGHT)%20==0) and (int(GAME_RATE)>=1 and int(GAME_RATE)<=20):
        win.destroy()
    else:
        answer = messagebox.askyesno("warning!", "please follow the tips!")
        win.mainloop()

tk.Button(win, text="GO", width=10,command=get_input).grid(row=3, column=0, sticky="w", padx=10, pady=5)
win.mainloop()
```
     在这个模块里主要实现的是用户的界面输入，即用户可以按要求实现他想要的长度宽度和游戏速度，整体实现语言采用tkinter的包里面

#### (2).基础设置:
```python
WIDTH=int(WIDTH)
HEIGHT=int(HEIGHT)
GAME_RATE=float(GAME_RATE)
#（1）界面处理
#屏幕大小:
#错误码:
ERR=-1145141919810
#游戏颜色设置(black):
Background_Color=(0,0,0)
#（2）蛇的处理
#一小块蛇的身体大小:
BODY_SIZE=20
#蛇头:
HEAD=0
#等价大小(将蛇的身体平均放在整个格子中):
BLOCK_W=int(WIDTH/BODY_SIZE)
BLOCK_H=int(HEIGHT/BODY_SIZE)
```
     这里实现的是蛇的基础定义

#### (3).传值给class:
```python
from love_eating_snake_not_ai_class import value_tranport
value_tranport(WIDTH,HEIGHT,BLOCK_H,BLOCK_W,BODY_SIZE)
```
     此处实现的是把原函数的值传给class类，因为class类需要根据这些值进行初始化（具体的传值函数在class里面，所以此处进行import

#### (4).pygame流程初始化:
```python
#pygame开始界面:
def start():
        title_Font=pygame.font.Font(None,45)
        title_content=title_Font.render('love_eating_snake_not_ai', True, (255, 255, 255), (0, 0, 0))#黑底白字
        while True:
            Main_Display.fill(Background_Color)#背景黑色
            rect1=pygame.Rect(50,50,100,100)
            rect1.center=((WIDTH/2)-120,HEIGHT/2)
            Main_Display.blit(title_content,rect1)
            #下面的小字
            press_start=Main_Font.render('press anything to go on',True, (255, 255, 255))#白字黑底
            press_Rect=press_start.get_rect()
            press_Rect.topleft=(WIDTH-300,HEIGHT-30)
            Main_Display.blit(press_start,press_Rect)
            if check_press():#检查和进入下一层,任意键作为操作列表的第一个元素存在，所以从道理上讲是个true
                pygame.event.get()     
                return 
            pygame.display.update()

def end():
    def choose():
        for event in pygame.event.get():
            if event.type==pygame.KEYDOWN:
                if event.key==pygame.K_q:
                    pygame.quit()
                    sys.exit()
                elif event.key==pygame.K_a:
                    pygame.quit()
                    import love_eating_snake_combine
    pygame.quit()
    pygame.init()
    Main_Display1=pygame.display.set_mode((400,400))
    Main_Font1=pygame.font.Font(None,20)
    pygame.display.set_caption('end_board')
    title_Font1=pygame.font.Font(None,45)
    title_content1=title_Font1.render('Game over!!! You died!!!',True,(255,255,255),(0,0,0))
    while True:
        Main_Display1.fill((0,0,0))
        rect1=pygame.Rect(50,50,100,100)
        rect1.center=(80,200)
        Main_Display1.blit(title_content1,rect1)
        press_end=Main_Font1.render('q for quit or a for again!',True, (255, 255, 255))
        press_Rect1=press_end.get_rect()
        press_Rect1.topleft=(100,350)
        Main_Display1.blit(press_end,press_Rect1)
        if choose():
            pass
        pygame.display.update()

def net_generate():
    # 垂直方向
    for x in range(0, WIDTH, BODY_SIZE):
        pygame.draw.line(Main_Display, (40, 40, 40), (x, 0), (x, HEIGHT))
    # 水平方向
    for y in range(0, HEIGHT, BODY_SIZE):
        pygame.draw.line(Main_Display, (40, 40, 40), (0, y), (WIDTH, y))

#读取操作的函数：
def check_press():
    if len(pygame.event.get(QUIT))>0:
        close()
    key_events=pygame.event.get(KEYUP)#从quene中获取keyup的事件，keyup（key，mod））
    if len(key_events)==0:
        return None
    elif key_events[0].key==K_ESCAPE:#第一个操作
        close()
    return key_events[0].key #返回

def close():
    pygame.quit()
    sys.exit()
```
     start()函数，设置初始界面的中心词，tips提示，以及下标，还有进入游戏的条件（点击任意键）
     end()函数：结束游戏，并且与combine文件实现交互
     net_generate()函数:用pygame进行网格化，优化图形界面
     check_press()作用在整个流程中的用户键盘读取函数,这段代码的作用是检查是否有退出事件或按键释放事件发生，并将这些事件存储在变量key_events中。如果有QUIT事件发生，就调用close()函数关闭程序。
     close()函数：退出pygame


#### (5).class蛇类的实现:
```python
from love_eating_snake_not_ai_class import Snake_not_ai#在主函数里面引用snake_not_ai的类定义
#转向类
def value_tranport(width,height,block_h,block_w,body_size):
    global WIDTH,HEIGHT,BLOCK_H,BLOCK_W,BODY_SIZE,ERR,HEAD
    WIDTH=width
    HEIGHT=height
    BLOCK_H=block_h
    BLOCK_W=block_w
    BODY_SIZE=body_size
    ERR = -1145141919810
    HEAD=0
    #Main_Display = main_display

def transfer(main_display,main_font):
    global Main_Display,Main_Font
    Main_Display = main_display
    Main_Font = main_font
```
     首先，这两个是传值函数，因为在类里面本身没有这些参数，如果运行就会导致程序报错，所以我们通过传值函数，把这些参数引进类，这样就可以在类里面进行交互了。
```python
class Snake_not_ai:
    def __init__(self):
        self.score=None
        self.snake_locations=None
        self.food_location=None
        self.direction=None

    def same_pace(self,food_location):
        self.food_location=food_location 

    def same_score(self,score):
        self.score=score

    def same_turn(self,direction):
        self.direction=direction

    def same_locations(self,snake_locations):
        self.snake_locations=snake_locations
```
     类的初始化，以上有一些把类外部的参数读入类，因为我也不好确定哪一个参变量我需要，所以我将他读入类里面进行计算
```python
#得分函数：
    def scores(self,score):
        score_Content=Main_Font.render('scores:%s' % (self.score),True,(255,255,255))#白色的分数
        score_rect=score_Content.get_rect()
        score_rect.topleft=(WIDTH-100,10)
        Main_Display.blit(score_Content,score_rect)
        #这算是个公式了，先content决定内容的长相，然后get_rect(),再决定位置，最后用bilt结合一下

    #random爆米函数：
    def random_food(self,snake_locations):
        #这个函数随机生成了米
        mi=True
        while mi:
            food_location={'x':random.randint(0,BLOCK_W-1),'y':random.randint(0,BLOCK_H-1)}
            if food_location not in (self.snake_locations): #判断米的生成位置合不合法
                mi=False
        return food_location

    def random_food_show(self,food_location):
        #这个函数展示了米
        x=self.food_location['x']*BODY_SIZE #米的长度
        y=self.food_location['y']*BODY_SIZE#米的高度
        food_rect=pygame.Rect(x,y,BODY_SIZE,BODY_SIZE) #获取米的位置和大小
        pygame.draw.rect(Main_Display,(255,0,0),food_rect) #显示米

    #蛇蛇生成函数：
    def snake_show(self,snake_locations):
        x=self.snake_locations[0]['x']*BODY_SIZE
        y=self.snake_locations[0]['y']*BODY_SIZE
        Snake_head_rect=pygame.Rect(x,y,BODY_SIZE,BODY_SIZE)#蛇头部分的填充
        pygame.draw.rect(Main_Display,(255,127,0),Snake_head_rect)
        for location in self.snake_locations[1:]:
            x=location['x']*BODY_SIZE
            y=location['y']*BODY_SIZE
            Snake_part_Rect=pygame.Rect(x,y,BODY_SIZE,BODY_SIZE)
            pygame.draw.rect(Main_Display,(0,127,255),Snake_part_Rect)

    #转向函数：
    def turn_over(self,direction,snake_locations):
        if self.direction == 'up':
            NEW = {'x': self.snake_locations[HEAD]['x'],'y': self.snake_locations[HEAD]['y']-1}
        elif self.direction == 'down':
            NEW = {'x': self.snake_locations[HEAD]['x'],'y': self.snake_locations[HEAD]['y']+1}
        elif self.direction == 'left':
            NEW = {'x': self.snake_locations[HEAD]['x']-1,'y': self.snake_locations[HEAD]['y']}
        elif self.direction == 'right':
            NEW = {'x': self.snake_locations[HEAD]['x']+1,'y': self.snake_locations[HEAD]['y']}
        self.snake_locations.insert(0,NEW)
        return self.direction,self.snake_locations

    #判断函数：
    def check_boom(self,snake_locations):
        if(self.snake_locations[HEAD]['x']==-1) or (self.snake_locations[HEAD]['x']==BLOCK_W) or  (self.snake_locations[HEAD]['y']==-1) or (self.snake_locations[HEAD]['y']==BLOCK_H):
            return end()
        if self.snake_locations[HEAD] in self.snake_locations[1:]:
            return end()
```
     这里展示了人工蛇里面的一些函数：具体来说：
     scores得分函数：里面用pygame进行了初始化，并且规定了位置，展示了得分
     random_food随机食物函数：选择一个规定的合法空间，既不能在外面，也不能与蛇身重叠的地方放置一个食物
     random_food_show函数：将刚才产生的随机的一个food位置的词典，在图像上找到x，y并且表示出来
     snake显示函数：首先找到snake的头部，将其画出
     然后是对snake的身子进行刻画，颜色不一样，位置也不一样，所以需要两个不同的刻画
     turnover人工操作转向函数:这个函数比较简单，就是把蛇的上下左右四个方向动给画出来，但是需要说明的是，我们刻画蛇头就可以了，蛇的尾巴会根据蛇头出现
     check边界判断函数：如果蛇头出界了，或者是头吃到了身子，蛇死，返回end

#### (6).主程序和游戏初始化:
```python
def game_startal():
    #蛇的出生
    start_x = random.randint(5, BLOCK_W-8)
    start_y = random.randint(5, BLOCK_H-8)
    direction='right'
    snake_locations=[{'x': start_x, 'y': start_y},{'x': start_x-1, 'y': start_y},{'x': start_x-2, 'y': start_y}]
    snake=Snake_not_ai()
    snake.same_locations(snake_locations)
    food_location=snake.random_food(snake_locations)
    snake.same_pace(food_location)
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                close()
            #键盘读取操作
            if (event.type == KEYDOWN):
                if (event.key == K_LEFT) and (direction != 'right'):
                    direction = 'left'
                elif (event.key == K_RIGHT) and (direction != 'left'):
                    direction = 'right'
                elif (event.key == K_UP) and (direction != 'down'):
                    direction = 'up'
                elif (event.key == K_DOWN) and (direction != 'up'):
                    direction = 'down'
                elif (event.key == K_ESCAPE):
                    close()
        #检查snake是不是炸了：
        snake.check_boom(snake_locations)
        #snake的snake_locations：(吃东西)
        if (snake_locations[HEAD]['x']==food_location['x']) and (snake_locations[HEAD]['y']==food_location['y']):
            food_location=snake.random_food(snake_locations)
            snake.same_pace(food_location)
        else:
            del snake_locations[-1]
        #转向
        snake.same_turn(direction)
        snake.turn_over(direction,snake_locations)
        #开始运行
        Main_Display.fill(Background_Color)
        net_generate()
        snake.snake_show(snake_locations)
        snake.random_food_show(food_location)#
        a=(len(snake_locations)-3)
        snake.same_score(a)
        snake.scores(a)
        pygame.display.update()
        Snake_Clock.tick(GAME_RATE)
```
     首先先把蛇生成出来，并且规定初始方向，然后引用类进行传参和基础设置。while循环首先判断有没有quit。
     然后进行用户键盘读取，注意在用户输入之后蛇可能炸了，所以需要判断其合法性。然后就是判断蛇吃没吃到东西，如果蛇吃到了东西（逻辑：蛇头坐标等于食物坐标），食物进行传入并且同步化，产生新的食物，如果没有，减去蛇尾，因为蛇头动了一格，必须保证蛇的长度一致性。然后重置类里面的转向函数，将蛇的所有设定更新。
     从开始运行之后的注释就是每一次都要更新设定
     display.update()这个不能少了，不然就要寄
```python
#运行开始！
global Main_Display,Main_Font,Snake_Clock
pygame.init()
Snake_Clock=pygame.time.Clock()#snake clock的定义
Main_Display=pygame.display.set_mode((WIDTH,HEIGHT))#画图
Main_Font=pygame.font.Font(None,20)
from love_eating_snake_not_ai_class import transfer
transfer(Main_Display,Main_Font)
pygame.display.set_caption('love_eating_snake_ai.py')
start()
while True:
    game_startal()
```
     此处开始蛇开始一切正常的运行，根据我们的介绍顺序，首先这里是pygame，然后把三个global传入class进行同步，最后开始即可了

### (2).AI蛇：
#### (1).tkinter进入模块：
     # （1）界面处理
```python
# 屏幕大小:
import tkinter as tk
from tkinter import messagebox

win = tk.Tk()
win.title("snake_ai")
screenWidth = win.winfo_screenwidth()  # 获取显示区域的宽度
screenHeight = win.winfo_screenheight()  # 获取显示区域的高度
width = 300  # 设定窗口宽度
height = 160  # 设定窗口高度
left = (screenWidth - width) / 2
top = (screenHeight - height) / 2
# 在设定宽度和高度的基础上指定窗口相对于屏幕左上角的偏移位置
win.geometry("%dx%d+%d+%d" % (width, height, left, top))
win.resizable(0, 0)
win.resizable(0, 0)
# 将俩个标签分别布置在第一行、第二行
tk.Label(win, text="WIDTH(300-1200 & WIDTH%20=0)").grid(row=0)
tk.Label(win, text="HEIGHT(300-1200 & HEIGHT%20=0)").grid(row=1)
tk.Label(win, text="GAME_RATE(1-500)").grid(row=2)
# 创建输入框控件
e1 = tk.Entry(win)
e2 = tk.Entry(win)
e3 = tk.Entry(win)
e1.grid(row=0, column=1, padx=10, pady=5)
e2.grid(row=1, column=1, padx=10, pady=5)
e3.grid(row=2, column=1, padx=10, pady=5)
# 使用 grid()的函数来布局，并控制按钮的显示位置
def get_input():
    global WIDTH, HEIGHT, GAME_RATE
    WIDTH = e1.get()
    HEIGHT = e2.get()
    GAME_RATE = e3.get()
    if (int(WIDTH) >= 300 and int(WIDTH) <= 1200 and int(WIDTH) % 20 == 0) and (
            int(HEIGHT) >= 300 and int(HEIGHT) <= 1200 and int(HEIGHT) % 20 == 0) and (
            int(GAME_RATE) >= 1 and int(GAME_RATE) <= 500):
        win.destroy()
    else:
        answer = messagebox.askyesno("warning!", "please follow the tips!")
        win.mainloop()
tk.Button(win, text="GO", width=10, command=get_input).grid(row=3, column=0, sticky="w", padx=10, pady=5)
win.mainloop()
```
     基本实现功能与上面一样，不多说

#### （2）基础设置：
```python
#基础设置
WIDTH = int(WIDTH)
HEIGHT = int(HEIGHT)
GAME_RATE = int(GAME_RATE)
# 错误码
ERR = -1145141919810
# 蛇的大小
BODY_SIZE = 20
# 等价的运动区域大小
BLOCK_W = int(WIDTH / BODY_SIZE)
BLOCK_H = int(HEIGHT / BODY_SIZE)
FIELD_SIZE = BLOCK_W * BLOCK_H
# 背景颜色
Background_Color = (0, 0, 0)
# 蛇头索引
HEAD = 0
# 运动方向
best_move = ERR
# 不同东西在矩阵里用不同的数字表示
FOOD = 0
FREE_PLACE = (BLOCK_W + 1) * (BLOCK_H + 1)
BODY_PLACE = 2 * FREE_PLACE
# 运动方向
move_directions = {'left': -1, 'right': 1, 'up': -BLOCK_W, 'down': BLOCK_W}
```
     这里的设定就要多一些，并且需要解释一下了。具体来说，ai并不知道它在哪，除了一些基础设置，我们需要蛇的移动方向设定。并且引入一个最重要的思路，用一位数组表示平面坐标，具体来说就是把一排满了之后加一个高*坐标。我们把food用0表示，在等会矩阵board里面蛇可以找到。然后还有一个点就是food的表示不会影响free和body。freeplace和bodyplace就是空的部分和蛇身占有的部分，这就是用一维数组的优势了。movedirection也就是根据一维数组的变化写的

#### (3).传值给class:
```python
from love_eating_snake_ai_class import value_tranport
value_tranport(WIDTH,HEIGHT,BLOCK_H,BLOCK_W,FREE_PLACE,BODY_PLACE,FIELD_SIZE,BODY_SIZE,best_move)
```
     同上，不然找不到需要的数据，因为class里面并没有。。

#### （4）.pygame流程控制
```python
def check_press():
    if len(pygame.event.get(QUIT)) > 0:
        close()
    KeyUp_Events = pygame.event.get(KEYUP)
    if len(KeyUp_Events) == 0:
        return None
    elif KeyUp_Events[0].key == K_ESCAPE:#退出
        close()
    return KeyUp_Events[0].key

# 画网格
def net_generate():
    # 垂直方向
    for x in range(0, WIDTH, BODY_SIZE):
        pygame.draw.line(Main_Display, (40, 40, 40), (x, 0), (x, HEIGHT))
    # 水平方向
    for y in range(0, HEIGHT, BODY_SIZE):
        pygame.draw.line(Main_Display, (40, 40, 40), (0, y), (WIDTH, y))

# 显示开始界面
def start():
    title_Font = pygame.font.Font(None, 45)
    title_content = title_Font.render('love_eating_snake(ai)', True, (255, 255, 255), (0, 0, 0))  # 黑底白字
    while True:
        Main_Display.fill(Background_Color)  # 背景黑色
        rect1 = pygame.Rect(50, 50, 100, 100)
        rect1.center = ((WIDTH / 2) - 70, HEIGHT / 2)
        Main_Display.blit(title_content, rect1)
        # 下面的小字
        press_start = Main_Font.render('press anything to go on', True, (255, 255, 255))  # 白字黑底
        press_Rect = press_start.get_rect()
        press_Rect.topleft = (WIDTH - 300, HEIGHT - 30)
        Main_Display.blit(press_start, press_Rect)
        if check_press():  # 检查和进入下一层,任意键作为操作列表的第一个元素存在，所以从道理上讲是个true
            pygame.event.get()
            return
        pygame.display.update()

# 显示结束界面
def end():
    def choose():
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_q:
                    pygame.quit()
                    sys.exit()
                elif event.key == pygame.K_a:
                    pygame.quit()
                    import love_eating_snake_combine
    pygame.quit()
    pygame.init()
    Main_Display1 = pygame.display.set_mode((400, 400))
    Main_Font1 = pygame.font.Font(None, 20)
    pygame.display.set_caption('end_board')
    title_Font1 = pygame.font.Font(None, 22)
    title_content1 = title_Font1.render('Game over!(maybe there is no solution/or ended)', True, (255, 255, 255),(0, 0, 0))
    while True:
        Main_Display1.fill((0, 0, 0))
        rect1 = pygame.Rect(50, 50, 100, 100)
        rect1.center = (80, 200)
        Main_Display1.blit(title_content1, rect1)
        press_end = Main_Font1.render('q for quit or a for again!', True, (255, 255, 255))
        press_Rect1 = press_end.get_rect()
        press_Rect1.topleft = (100, 350)
        Main_Display1.blit(press_end, press_Rect1)
        if choose():
            pass
        pygame.display.update()
```
     这里的所有内容都与人工蛇一样

#### (5).class_ai蛇介绍：
```python
import pygame
import sys
from pygame.locals import *
def value_tranport(width,height,block_h,block_w,free_place,body_place,field_size,body_size,Best_move):
    global WIDTH,HEIGHT,BLOCK_H,BLOCK_W,FREE_PLACE,BODY_PLACE,FIELD_SIZE,BODY_SIZE,best_move,FOOD,move_directions,HEAD,ERR
    WIDTH=width
    HEIGHT=height
    BLOCK_H=block_h
    BLOCK_W=block_w
    FREE_PLACE=free_place
    BODY_PLACE=body_place
    FIELD_SIZE=field_size
    BODY_SIZE=body_size
    best_move=Best_move
    FOOD = 0
    move_directions = {'left': -1, 'right': 1, 'up': -BLOCK_W, 'down': BLOCK_W}
    HEAD = 0
    ERR = -1145141919810
    #Main_Display = main_display

def transfer(main_display,main_font):
    global Main_Display,Main_Font
    Main_Display = main_display
    Main_Font = main_font
```
     将需要的参数传入这个类

```python
class Snake_ai:
    def __init__(self):
        self.score = None
        self.food_location = None
        self.index = None
        self.snake = None
        self.board = None
        self.move_direction = None
        self.direction = None

    # 传入函数：
    def same_scores(self, score):
        self.score = score

    def same_food_location(self, food_location):
        self.food_location = food_location

    def same_index(self, index):
        self.index = index

    def same_snake(self, snake):
        self.snake = snake

    def same_board(self, board):
        self.board = board

    def same_move_directionss(self, move_direction):
        self.move_directions = move_direction

    def same_direction(self, direction):
        self.direction = direction
```
     同理，这个地方也是重置所有的函数值，因为在class函数执行的时候需要修改
```python
# 显示当前得分
    def scores(self, score):
        score_Content = Main_Font.render('得分：%s' % (self.score), True, (255, 255, 255))
        score_Rect = score_Content.get_rect()
        score_Rect.topleft = (WIDTH - 120, 10)
        Main_Display.blit(score_Content, score_Rect)

    # 爆米位置（出现食物）
    def random_food(self, snake):
        flag = True
        while flag:
            food_location = {'x': random.randint(0, BLOCK_W - 1), 'y': random.randint(0, BLOCK_H - 1)}#出去边界情况之后出现食物
            if food_location not in self.snake:#不与蛇重复
                flag = False
        return food_location
    # 随机爆米显示函数（把食物展示出来）
    def random_food_show(self, food_location):
        x = self.food_location['x'] * BODY_SIZE
        y = self.food_location['y'] * BODY_SIZE
        food_rect = pygame.Rect(x, y, BODY_SIZE, BODY_SIZE)
        pygame.draw.rect(Main_Display, (255, 0, 0), food_rect)

    # 蛇蛇显示函数
    def snake_show(self, snake):
        x = self.snake[0]['x'] * BODY_SIZE#蛇头
        y = self.snake[0]['y'] * BODY_SIZE#蛇头
        Snake_head_Rect = pygame.Rect(x, y, BODY_SIZE, BODY_SIZE)
        pygame.draw.rect(Main_Display, (255, 127, 0), Snake_head_Rect)
        for location in self.snake[1:]:
            x = location['x'] * BODY_SIZE#蛇身
            y = location['y'] * BODY_SIZE#蛇身
            Snake_part_Rect = pygame.Rect(x, y, BODY_SIZE, BODY_SIZE)
            pygame.draw.rect(Main_Display, (0, 127, 255), Snake_part_Rect)
```
     这四个函数与人工蛇一样，不在多说
```python
# 判断该位置是否为空
    def place_free(self, index, snake):
        location_x = self.index % BLOCK_W
        location_y = self.index // BLOCK_W
        index1 = {'x': location_x, 'y': location_y}
        return (index1 not in self.snake)#为空
```
     这个函数，就是判断一个位置是不是空的地方，在重置board里面有freeplace的作用
```python
# 重置board
    def board_reset(self, snake, board, food_location):
        temp_board = self.board[:]
        food_index = self.food_location['x'] + self.food_location['y'] * BLOCK_W#食物坐标
        for i in range(FIELD_SIZE):#在场地里面搜索
            self.same_index(i)#重置
            if i == food_index:
                temp_board[i] = FOOD#是食物就归为食物
            elif Snake_ai.place_free(self, i, self.snake):
                temp_board[i] = FREE_PLACE#没有就free
            else:
                temp_board[i] = BODY_PLACE#有就是蛇
        # Snake_ai.same_board(self,temp_board)####################possible error
        return temp_board#返回更新的board
```
     因为ai蛇不会有任何的人工操作，很多时候比如bfs和vis之后蛇需要重置版面，这个时候我就需要重新把版面属性刷一下，不然后果就不太好（说白了ai会死机）
```python
# 检查位置index是否可以向当前move方向运动
    def check_move(self, index, move_directions):
        flag = False
        if self.move_directions == 'left':#向左走
            if self.index % BLOCK_W > 0:
                flag = True
            else:
                flag = False
        elif self.move_directions == 'right':#向右走
            if self.index % BLOCK_W < BLOCK_W - 1:
                flag = True
            else:
                flag = False
        elif self.move_directions == 'up':#向上走
            if self.index > BLOCK_W - 1:
                flag = True
            else:
                flag = False
        elif self.move_directions == 'down':#向下走
            if self.index < FIELD_SIZE - BLOCK_W:
                flag = True
            else:
                flag = False
        return flag
```
     ai需要一个函数来判断可以朝哪边走，比如这个函数，只要位置合法，不超出边界，就可以走，当然，有人说可能没有判断蛇自己吃自己的问题，这个别急，后面所有的函数都保证了不会吃到自己
```python
# BFS
    def BFS(self, snake, food_location, board):
        temp_board = self.board[:]  # 建立一个临时版
        food_index = self.food_location['x'] +self.food_location['y'] * BLOCK_W  # 找出食物坐标
        # Snake_ai.same_food_location(self,food_index)
        # Snake_ai.same_board(self,board)出现问题
        res = []  # 存储路径走法
        res.append(food_index)  # 第一位定位为食物坐标
        inres = [0] * FIELD_SIZE#把board遍历为0
        flag = False
        while len(res) != 0:  # 如果存在情况
            index = res.pop(0)  # 将食物坐标整成这个，并且pop出去
            Snake_ai.same_index(self, index)  # 传入index
            if inres[index] == 1:#变为1
                continue
            inres[index] = 1
            for move_direction in ['left', 'right', 'up', 'down']:  # 每个方向都查一次
                Snake_ai.same_move_directionss(self, move_direction)#重置
                if Snake_ai.check_move(self, index, move_direction):#可以走
                    if (index + move_directions[move_direction]) == (self.snake[HEAD]['x'] + self.snake[HEAD]['y'] * BLOCK_W):#找到
                        flag = True
                    # print(temp_board[index+move_directions[move_direction]])
                    if temp_board[index + move_directions[move_direction]] < BODY_PLACE:#没找到
                        if temp_board[index + move_directions[move_direction]] > temp_board[index] + 1:#大于1的情况，继续走
                            temp_board[index + move_directions[move_direction]] = temp_board[index] + 1
                            Snake_ai.same_board(self, temp_board)
                            # print(self.board)
                        if inres[index + move_directions[move_direction]] == 0:#找到，加1
                            res.append(index + move_directions[move_direction])
        return (flag, temp_board)#返回一个bool值（是否找到），另外一个路线
```
     bfs这里主要是不停的找到食物的广搜，我觉得注释已经写的非常清楚了，就不再赘述了
```python
# 找到食物的最短路径
    def shortest_way(self, snake, board):
        best_move = ERR
        min_way = BODY_PLACE
        for move_direction in ['left', 'right', 'up', 'down']:
            index = self.snake[HEAD]['x'] + self.snake[HEAD]['y'] * BLOCK_W#蛇头坐标
            Snake_ai.same_index(self, index)#重置
            Snake_ai.same_move_directionss(self, move_direction)#重置
            if Snake_ai.check_move(self, index, move_direction) and (self.board[index + move_directions[move_direction]] < min_way):#可以走，而且还小
                min_way = self.board[index + move_directions[move_direction]]#最小路径
                best_move = move_direction#最好的方向
        return best_move
```
     根据这个蛇的实现，我们可以知道有这个思路：蛇找食物：最小路径；蛇找尾巴，最长路径。这个就是一个找最小路径的函数，具体实现看注释
```python
# 找到移动后蛇头的位置
    def head_place(self, snake, direction):
        if self.direction == 'up':#向上
            newHead = {'x': self.snake[HEAD]['x'], 'y': self.snake[HEAD]['y'] - 1}
        elif self.direction == 'down':#向下
            newHead = {'x': self.snake[HEAD]['x'], 'y': self.snake[HEAD]['y'] + 1}
        elif self.direction == 'left':#想左
            newHead = {'x': self.snake[HEAD]['x'] - 1, 'y': self.snake[HEAD]['y']}
        elif self.direction == 'right':#向右
            newHead = {'x': self.snake[HEAD]['x'] + 1, 'y': self.snake[HEAD]['y']}
        # print(newHead)
        return newHead
```
     这是一个找蛇运动一个direction时候蛇头的位置，因为蛇的控制就是由蛇头确定的，返回一个新的头坐标
```python
# 虚拟运行一次蛇，看是不是有通路（没有问题）#让蛇更聪明，这样蛇不会跑死
    def vis_snake(self, snake, board, food_location):
        temp_snake = self.snake[:]
        temp_board = self.board[:]#临时板和蛇
        reset_tboard = Snake_ai.board_reset(self, temp_snake, temp_board, self.food_location)
        temp_board = reset_tboard
        Snake_ai.same_board(self, temp_board)  # 重置
        food_eated = False
        while not food_eated:#没有吃到东西
            Snake_ai.same_board(self, temp_board)
            Snake_ai.same_snake(self, temp_snake)#传入
            refresh_tboard = Snake_ai.BFS(self, temp_snake, self.food_location, temp_board)[1]#bfs找到路径
            temp_board = refresh_tboard
            Snake_ai.same_board(self, temp_board)  # 重置
            move_direction1 = Snake_ai.shortest_way(self, temp_snake, temp_board)#最小移动方向是最小路径
            snake_locations = temp_snake[:]  # 目前为止正确###################################################################################
            Snake_ai.same_snake(self, snake_locations)
            Snake_ai.same_direction(self, move_direction1)
            # print(self.direction)
            temp_snake.insert(0, Snake_ai.head_place(self, snake_locations, move_direction1))#虚拟蛇移动
            # 如果新的蛇头正好是食物的位置
            if temp_snake[HEAD] == self.food_location:
                reset_tboard = Snake_ai.board_reset(self, temp_snake, temp_board, self.food_location)
                temp_board = reset_tboard
                Snake_ai.same_board(self, temp_board)
                food_index = self.food_location['x'] + self.food_location['y'] * BLOCK_W
                temp_board[food_index] = BODY_PLACE
                food_eated = True#结束
            else:  # 如果并不是
                print(temp_snake[0]['x'],temp_snake[0]['y'])
                newHead_index = temp_snake[0]['x'] + temp_snake[0]['y'] * BLOCK_W
                temp_board[newHead_index] = BODY_PLACE#移动
                tail_index = temp_snake[-1]['x'] + temp_snake[-1]['y'] * BLOCK_W
                temp_board[tail_index] = FREE_PLACE#移动
                del temp_snake[-1]#移动
        print("yes",temp_snake,food_location)
        return temp_snake, temp_board    
```
     这个函数的实现有必要说一下，虽然思路是借鉴的。但是我还是觉得很绝，相当于一个虚拟蛇去找一条路，这个路是由bfs和shortest一起找出来的，这样蛇不会死的情况下，蛇仍然会运行，所有操作也意义在注释里面了
```python
# 找蛇头到蛇尾的安全函数，
    def tail_find(self, snake, board, food_location):
        temp_board = self.board[:]
        temp_snake = self.snake[:]
        # 将蛇尾看作食物
        tail_index = temp_snake[-1]['x'] + temp_snake[-1]['y'] * BLOCK_W
        temp_board[tail_index] = FOOD
        Snake_ai.same_board(self, temp_board)  # 重置
        v_food = temp_snake[-1]
        # 食物看作蛇身(重复赋值了)
        food_index = self.food_location['x'] + self.food_location['y'] * BLOCK_W
        temp_board[food_index] = BODY_PLACE
        # 求得每个位置到蛇尾的路径长度
        Snake_ai.same_board(self, temp_board)
        Snake_ai.same_snake(self, temp_snake)  #############
        Snake_ai.same_food_location(self, v_food)
        result, refresh_tboard = Snake_ai.BFS(self, temp_snake, v_food, temp_board)#广搜
        temp_board = refresh_tboard
        Snake_ai.same_board(self, temp_board)  # 重置
        for move_direction in ['left', 'right', 'up', 'down']:
            index = temp_snake[HEAD]['x'] + temp_snake[HEAD]['y'] * BLOCK_W#头坐标
            tail_index = temp_snake[-1]['x'] + temp_snake[-1]['y'] * BLOCK_W#尾坐标
            Snake_ai.same_index(self, index)
            Snake_ai.same_move_directionss(self, move_direction)
            # print(index,self.index)########################################
            if Snake_ai.check_move(self, index, move_direction) and (index + move_directions[move_direction] == tail_index) and (len(temp_snake) >= 3):
                result = False
        return result
```
     讲一下这个函数实现的功能，蛇头到蛇尾是否安全，其实这个函数是与vis一起用的，相当于vis运行的过程中需要保证蛇也有一条到尾巴的通路，不然贪吃蛇就把自己贪死了，说到底主要的蛇还是没啥用，就是按照vis走的傀儡罢了
```python
# 找尾巴的最长路径函数
    def longest_way(self, snake, board):
        best_move = ERR
        max_distance = -1
        for move_direction in ['left', 'right', 'up', 'down']:
            index = self.snake[HEAD]['x'] + self.snake[HEAD]['y'] * BLOCK_W
            Snake_ai.same_index(self, index)
            Snake_ai.same_move_directionss(self, move_direction)#重置
            if Snake_ai.check_move(self, index, move_direction) and (
                    self.board[index + move_directions[move_direction]] > max_distance) and (
                    self.board[index + move_directions[move_direction]] < FREE_PLACE):#可以走
                max_distance = self.board[index + move_directions[move_direction]]#蛇头走
                best_move = move_direction
                # print(best_move)
        return best_move#就是一个不停更新找路径的过程
```
     这个就是刚才提到的思路，蛇找尾巴，走最长路径，不然蛇一会就把自己绕死了
```python
# 让蛇头朝着蛇尾运行一步
    def move_to_tail(self, snake, board, food_location):
        temp_snake = self.snake[:]
        Snake_ai.same_snake(self, temp_snake)  # 重置
        temp_board = Snake_ai.board_reset(self, temp_snake, self.board, self.food_location)
        # 将蛇尾看作食物
        tail_index = temp_snake[-1]['x'] + temp_snake[-1]['y'] * BLOCK_W
        temp_board[tail_index] = FOOD
        v_food = temp_snake[-1]
        # 食物看作蛇身
        food_index = self.food_location['x'] + self.food_location['y'] * BLOCK_W
        temp_board[food_index] = BODY_PLACE
        # 求得每个位置到蛇尾的路径长度
        Snake_ai.same_board(self, temp_board)
        Snake_ai.same_snake(self, temp_snake)
        Snake_ai.same_food_location(self, v_food)
        result, refresh_tboard = Snake_ai.BFS(self, temp_snake, v_food, temp_board)  # 广搜走最小
        temp_board = refresh_tboard
        Snake_ai.same_snake(self, temp_snake)
        # 重置
        #temp_board[tail_index] = BODY_PLACE
        Snake_ai.same_board(self, temp_board)
        return Snake_ai.longest_way(self, temp_snake, temp_board)
```
     这个函数就是让蛇朝着蛇尾巴走一步，但是先实现板的temp化，看注释吧，这个思路很简单
```python
     # 如果蛇和食物间有路径
    # 则需要找一条安全的路径到食物
    def safe_way(self, snake, board, food_location):
        safe_ways = ERR
        real_snake = self.snake[:]
        real_board = self.board[:]
        real_food_location = self.food_location
        v_snake, v_board = Snake_ai.vis_snake(self, self.snake, self.board, self.food_location)
        Snake_ai.same_snake(self, v_snake)
        Snake_ai.same_board(self, v_board)
        if Snake_ai.tail_find(self, v_snake, v_board, self.food_location):
            #####断点find
            #print("?????")
            Snake_ai.same_food_location(self,real_food_location)
            Snake_ai.same_snake(self, real_snake)
            Snake_ai.same_board(self,real_board)
            safe_ways = Snake_ai.shortest_way(self, real_snake, real_board)  # 如果可以找到路径就走最小路径
        else:
            #####
            #####
            #print("!!!!!")
            Snake_ai.same_snake(self,real_snake)
            Snake_ai.same_board(self,real_board)
            Snake_ai.same_food_location(self, real_food_location)
            safe_ways = Snake_ai.move_to_tail(self, real_snake, real_board, self.food_location)  # 没有就朝着尾巴走
            Snake_ai.same_food_location(self, real_food_location)
            Snake_ai.same_board(self, real_board)
            Snake_ai.same_snake(self, real_snake)
        return safe_ways
```
     这个函数巨容易错，至少debug整了8个小时，说一下干什么的：首先蛇走之前用vis查一下路径，如果到尾巴安全，最小路径吃东西，如果不安全，最长路径走尾巴
```python
# 蛇陷入“死路”的时候走几步，看是不是真的走死了
    def wander(self, snake, board, food_location):
        best_move = ERR
        reset_board = Snake_ai.board_reset(self, self.snake, self.board, self.food_location)
        board = reset_board
        Snake_ai.same_board(self, board)
        result, refresh_board = Snake_ai.BFS(self, self.snake, self.food_location, self.board)  # 广搜一次
        Snake_ai.same_board(self, refresh_board)
        min_way = BODY_PLACE
        for move_direction in ['left', 'right', 'up', 'down']:
            index = self.snake[HEAD]['x'] + self.snake[HEAD]['y'] * BLOCK_W
            Snake_ai.same_index(self, index)
            Snake_ai.same_move_directionss(self, move_direction)#重置
            if Snake_ai.check_move(self, index, move_direction) and (
                    self.board[index + move_directions[move_direction]] < min_way):
                min_way = self.board[index + move_directions[move_direction]]
                best_move = move_direction
                # print(best_move)
        Snake_ai.same_board(self, board)
        return best_move
```
     不排除蛇会在以上情况全部无解，所以我设置了一个wander函数，蛇如果全部无解，随便走一步，因为在走了之后，有可能出现新解法，所以蛇需要判断一下

#### (6).流程控制函数介绍：
```python
# 蛇在最后一般剩下10个左右的时候会产生无解的情况，我们将这种情况纳入处理范围（蛇可以自动退出）
def end_the_game(time_now):
    time_temp_now = time.time()
    if time_temp_now - time_now >= 20:
        return end()
    else:
        pass
        print(time_temp_now-time_now)

# 一个估值函数：
def evaluate(w, h):
    w = BLOCK_W  # 10s
    h = BLOCK_H  # 10s
    time = 20 + (BLOCK_H - 15) * 0.5 + (BLOCK_W - 15) * 0.5
    return time
```
     由于贪吃蛇是一个随机性很强的游戏，所以一定存在无解的情况了，根据用户选择的大小不一样，可以选择不一样的蛇的游戏结束时间。吃了一个食物时间会重置，如果一直没有吃到的话，蛇自己是不知道的，我们用时间来提醒它

#### (7).主函数介绍：
```python
# 运行游戏
def Run_Game():
    # 一维数组来表示蛇运动的矩形场地
    board = [0] * FIELD_SIZE  # 全部为零
    # 蛇出生地
    start_x = random.randint(5, BLOCK_W - 8)
    start_y = random.randint(5, BLOCK_H - 8)
    snake_locations = [{'x': start_x, 'y': start_y}]#蛇初始化
    snake = Snake_ai()  # 类定义
    snake.same_snake(snake_locations)  # 传值
    snake.same_board(board)
    food_location = snake.random_food(snake_locations)#food_location定义
    snake.same_food_location(food_location)  # 传值
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                close()
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    close()
        # 进行基本塑造
        # print(snake_locations)
        Main_Display.fill(Background_Color)
        net_generate()
        snake.snake_show(snake_locations)
        snake.random_food_show(food_location)
        a = len(snake_locations) - 1
        snake.same_scores(a)
        snake.scores(a)
        # 初始化开始
        reset_board = snake.board_reset(snake_locations, board, food_location)  # 每走一次，就对这个board进行重置
        board = reset_board
        snake.same_board(board)#重置
        result, refresh_board = snake.BFS(snake_locations, food_location, board)  # 每走一次，就对这个进行广搜
        board = refresh_board
        snake.same_board(board)#重置
        # print(board,food_location,snake_locations)#这里是有传值的
        # 开始
        # print(food_location)
        if result:  # 如果蛇可以吃到食物
            best_move = snake.safe_way(snake_locations, board, food_location)#最好路径就是蛇的安全路径
        else:
            #print(snake_locations)
            best_move = snake.move_to_tail(snake_locations, board, food_location)  # 没有就追着尾巴跑
            snake.same_food_location(food_location)#将此处三个值重置
            snake.same_board(board)#将此处三个值重置
            snake.same_snake(snake_locations)#将此处三个值重置
            # print(snake_locations,board,food_location)
            #print("no!!!")
        if best_move == ERR:  #没有解
            best_move = snake.wander(snake_locations, board, food_location)  # 在bfs搜不到的时候，蛇进行wander这样就保证可能走几步就有解了
            #print("no!!!!!!!")
        if best_move != ERR:  # 如果可以走
            snake.same_direction(best_move) #重置
            #print(best_move)  # 有解，而且可以吃一个了，说明第二次没有起作用#############################################################
            newHead1 = snake.head_place(snake_locations, best_move)  # 新走的蛇头的坐标定义为一个newhead
            snake_locations.insert(0, newHead1) #新增一个snake_location
            # snake.same_snake(snake_locations)
            head_index = snake_locations[HEAD]['x'] + snake_locations[HEAD]['y'] * BLOCK_W  # 找出蛇的头坐标
            tail_index = snake_locations[-1]['x'] + snake_locations[-1]['y'] * BLOCK_W  # 找出蛇的尾坐标
            if (snake_locations[HEAD]['x'] == food_location['x']) and (snake_locations[HEAD]['y'] == food_location['y']):  # 吃到东西了
                # print(snake_locations[HEAD]['x'],food_location['x'])
                #print(food_location)
                board[head_index] = BODY_PLACE  # 头坐标属于body（将食物吃进来）
                # print(BODY_PLACE)
                # snake.same_snake(snake_locations)
                # snake.same_board(board)
                snake.same_snake(snake_locations)#重置
                snake.same_board(board)#重置
                time_now = time.time()#记录时间
                if len(snake_locations) < FIELD_SIZE:  # 没满
                    food_location = snake.random_food(snake_locations)  # 继续生成食物
                    snake.same_food_location(food_location)#重置
                    #print("yes")
            else:  # 如果不是一样的坐标
                board[head_index] = BODY_PLACE  # head是body
                board[tail_index] = FREE_PLACE  # tail是空的
                #print(snake_locations)
                del snake_locations[-1]  # 尾部减一，相当于动了一步
                snake.same_snake(snake_locations)#重置
                snake.same_board(board)#重置
        else:  # 如果以上都没有解
            return end()#结束
        if len(snake_locations) - 1 >= 1:
            end_the_game(time_now)#吃了一个就开始计时
        pygame.display.update()
        Snake_Clock.tick(GAME_RATE)#更新

# 主函数
global Main_Display, Main_Font, Snake_Clock
pygame.init()#初始化
Snake_Clock = pygame.time.Clock()
Main_Display = pygame.display.set_mode((WIDTH, HEIGHT))
Main_Font = pygame.font.Font(None, 18)
from love_eating_snake_ai_class import transfer
transfer(Main_Display,Main_Font)
pygame.display.set_caption('AI_snake')
start()
while True:
    Run_Game()#主函数
```  
     不多说，看注释

## 三.实现效果
     不多说，内附视频